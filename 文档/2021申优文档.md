## 2021申优文档

2021/12/22/16:00

### 总结

* 写这篇文档主要目的是记录一下半个月来的不断尝试，也把走过的坑记录下来，说不定能帮助到之后的人。

* 通过数学归纳法我们可以看到，提升倍数和排名成绩是正相关的。这代表大部分选择生成mips代码的同学的编译器的“底子”实际上是差不多的，而使用了多少**优化方式、其效果如何**则最大程度地决定了编译器的性能优劣。

* 编译器基础功能部分会着重写一下**重构**方面的经历，细节部分在设计文档中有说（只有从自己挖的坑里爬出来才明白为什么书上的理论是正确的）

* 我主要做了如下的**优化**，在这里也给他们的效果大致打上一个分数，在之后会详细说明：

  * 常量合并，复制传播（1分）
  * 原编译器产生的冗余变量删除，冗余代码删除（5分）
  * 原寄存器设计改进等：传参（5分）
  * 运算强度削弱：除法（0分）
  * 块、数据流（5分）
  * 死代码删除（3分）
  * 临时寄存器分配（4分）
  * 全局寄存器分配（4分）

### 基础功能注意事项

#### 总架构

* 首先调用lexical.cpp的**词法分析程序**，生成**token列表**。之后使用error.cpp中的**错误处理**程序和error_grammar进行**错误分析**，单独处理错误。使用mips_grammar在**递归下降**中调用midcode.cpp**生成中间代码**。接着使用optimize.cpp面向中间代码进行**优化**，之后调用mipsCode.cpp和符号表生成**mips代码**。

#### 词法分析

​	采用课本上的自动机的思路，使用if-else和switch的选择结构对于每一种情况分别讨论。将自动机转化为while或者for循环的结构，以单词为一个单位做个分析，输出至文件（存储在数据结构中）。

* **注释**

  需要针对//和/*的主食结构分别讨论，再加上本来的div含义，这三种情况的分类要注意避免杂糅

* **字符串输出**

  对于char[]类型的字符串，当使用cout流式输出时，要注意字符串的尾部需要加上一个'\0'

* 对于**回退**（retract）一定要仔细。否则输出信息极易被丢失。

* **词法分析后的数据存储**，一开始就想的是将token，string，line分别存储。但之后实现过程中发现可能存在匹配不上的风险，所以之后从新设计了新的数据结构对其进行了存储

  ```cpp
  struct completeSymbol{
      int symbol = 0;
      std::string stringContent;
      int line = 0;
  };
  ```

#### 语法分析

​	递归下降的设计思路，将每一个对象表示为了一个**函数**，负责该非终结符的处理。并且保持了**约定**，进入一个对象时，第一个字符已经被读好，离开时要输出该对象的信息并且预读下一个字符。由于顺序读取需要处理两个的预读，所以采用了读两遍的策略，重新读取词法分析输出的token序列。

* **预读**的问题。

  由于按照书上的预读策略，所以需要处理好token的打印归属问题。token预读的时候是不能输出的，否则会产生归属错误的情况。所以我设计了三个函数（效率不高），分别是只读不输出，同时读和输出，只输出，来配合完成任务。当然输出是因为任务导致，当被用于一个子模块时，这些问题就不复存在了。

  但是之后我又想，预读的策略目的是一遍便可以完成所有branch，既然我是两遍，预读本身就是没有意义的，所以这一点上设计有些瑕疵

* 文法理解错误：左递归消除后输出不一样，不能直接拆分

* 预读不能输出（顺序问题）采用了三个函数共同处理

* 注释相关的丢舍（实际上是和词法分析的配合）

* 递归下降的**判断细节**：

  由于之前递归下降的判断逻辑都为：如果出现A[B]c的情况，当需要判断B的存在时，可以用是不是c来判断。

  但是在错误处理中，尤其是IJK三类任务中，c有可能是缺失的，所以这种判断逻辑就行不通了。于是需要改变成判断First(B)的方式来进行判断。

#### 错误处理

​	将错误处理与原来的语法分析写在一起，此时语法分析更像是一个过程而不是一个步骤，之后的所有步骤都将建立在这个“递归下降”的过程中。由于错误处理相对独立，并且我的中间代码生成实际上也是写在“递归下降”的过程中，求和过于严重，于是我就粗暴的**将错误处理单拎出来来递归下降一遍**，如果没有报错则进行接下来的的步骤。所以出现了error_grammar.cpp和mips_grammar.cpp两个语法分析文件。

* error.txt的输出错误

  行号输出不尽相同，需要我们分别传参处理

* **E **需要去将函数调用中的实参分别和函数定义的形参完成比较，分析其是否类型一致。但是由于实参定义为EXP，最终可以递归到数字、变量、函数调用，EXP**嵌套**的组合上，无法直接判断其类型。所以我将涉及到的递归子函数的返回值赋予了变量维数的意义，逐级分析返回，最终给出分析Rparam的类型。
* **I J K **三个函数需要判断 **; ) ]** 这三个符号的缺失，属于语法分析维度。但由于递归下降的过程默认了他们的存在，当他们缺失时，会与原来的识别步骤产生矛盾。所以当我们发现它缺失报错后，需要默认他存在继续接下来的分析程序，以确保语法分析的完整性。
* **J **是识别 )，其涉及到了 Ident '(' [FuncRParams] ')' 这条语法规则，可以看到当）缺失时我们需要判断是否存在 [FuncRParams] 这一非终结符，其决定了我们程序的走向。所以我使用理论课学习的First集知识和行号判断，进行了识别。

#### 代码生成

​	大体思路是在**递归下降**的过程中直接完成**中间代码**的生成，之后根据**符号表和中间代码**完成对于**MIPS汇编代码**的生成。

* vector类型当其加入或删除元素的时候，如果外部有一个对于其中元素的引用，其会失效。
* $ra寄存器的值应该被记录在函数栈里，函数调用的前后存取。
* 函数传参需要等全部实参都解析完毕的时候一并push，之后再call函数，这样就可以避免参数归属错误，例如func(a,b, func(c))
* **mips地址空间**的分配使用，哪些部分可用，哪些部分大小合适等等。
* **函数栈**的必要性：在被递归函数、间接递归函数hack爆的时候恍然大悟，之前一直是相当于都处理成了静态变量，与内存空间有一一对应。

### 优化

#### 总结

​	都说优化的过程实际上是挖坑和填坑，确实如此。当你眼馋一个优化，决定着手开始做的时候，你就拿起了铲子。而当你~~把原先的代码改的面目全非~~ 写了上百行代码的时候，你的大坑已经初具规模。接下来，看到辅助测试满屏的报错，看到midcode mipscode突然出现众多奇异事件之后，你要明白需要还债了。一点一点在代码、中间代码、目标代码之间来回横跳，debug之路何其的艰难。但就算你把这个大坑给填上了，却可能突然发现他最终的样子比你刚挖的时候还要丑（负优化），于是你含泪ctrl z……

​	得益于我良好的版本管理习惯和日志书写习惯，我的工作过程还是比较完整地被记录了下来。接下来我会把我做的优化和效果一一列举一下，并且把~~懒得做~~ 没时间做，不会做的优化列举一下。毕竟参考了很多学长的文档，做好接力棒。

* 我主要做了如下的**优化**，在这里也给他们的效果大致打上一个分数（**满分5分**）：

  * 常量合并，复制传播（1分）
  * 原编译器产生的冗余变量删除，冗余代码删除（5分）
  * 原寄存器设计改进等：传参（5分）
  * 运算强度削弱：除法（0分）
  * 块、数据流（5分）
  * 死代码删除（3分）
  * 临时寄存器分配（4分）
  * 全局寄存器分配（4分）

* 我的寄存器的使用：

  ```cpp
  /*
   *  $gp不变，存储全局变量,从低到高
   *  $sp函数尾,$fp函数头 运行栈（从低到高）：栈长、返回绝对地址、参数、局部变量
   *  $ra函数ret
   *  $a1, $a2, $a3 函数传参用
   *  $t0, $t1, $t2 运算用
   *  $t3, $t4, $t5 ins_Var 中间变量使用
   *  $t6,$t7,$t8,$t9,$s1,$s2,$s3,$s4,$s5,$s6,$s7,$v1,$k0,$k1 var_Var 跨基本块变量使用
   *  $a0, $v0 与 syscall使用
   *  $s0 函数返回值
   *  hi, lo
   */
  ```

* 只将寄存器分为了两类，分别是临时寄存器和全局寄存器。但是他们与书中的定义有所区别。临时寄存器专门分配给我新生成的临时变量，所以其生命周期不出基本块，使用临时寄存器池便可轻松解决。而全局寄存器就是剩下的所有变量，需要仔细地处理存取过程，否则就会产生正确性问题。

#### 冗余变量、代码删除（5分）

* 毫无疑问，最好的优化方式实际上是针对自己的代码生成部分的漏洞进行填补。修改自己的的代码省时省力，并且具有普遍性，其会频繁出现在每一个测试样例的各个角落。而且效果非常好，可以说是事半功倍，强烈推荐

* **冗余变量**

  是递归下降留下来的荼毒，**解耦必然意味着传递成本的增加**，体现在递归下降中就是需要新生成变量来进行值传递。例如：

  ```
  li $t1,1
  move $a3,$t1
  
  $t6 = 0
  li $t1,0
  move $t0,$t1
  move $t6,$t0
  
  add $t0,$t4,$t7
  move $t5,$t0
  
  ins_10 = ins_9 % 10
  variable_3 = ins_10
  ```

  可以直接窥孔解决掉，省时省力

* **冗余指令**

  有一部分的指令其实是多余的，或者其强度可以被削弱的

  ```
  PUSHADDR variable_4[0]
  li $t1,0
  li $t0,4
  mult $t0,$t1
  mflo $t0
  ```

  ​	该代码块是在计算数组的地址偏移，显然其可以被优化为 li $t0, 0，编译器直接计算即可。凭借这个优化，我的testfile2直接一度杀入前十名（害怕

  * **mul指令**比mult+mflo操作要少一个other指令

  * subi $t0, $t1, 100用addi $t0,$t1, -100替换。因为mars会把subi拆解成两条语句。

  * **while可以改写**（有坑）

    上面是原始while结构，下面是改进了的while结构

    ```cpp
    label1:
    if !<条件> goto label2
     <语句>
    goto label1
    label2:
    ```

    ```cpp
    goto label2
    label1:
     <语句>
    label2:
    if <条件> goto label1
    label3:
    ```

    显然，每次循环可以少一条goto语句。但是麻烦的点有不少：

    * 显然文法是：while\<cond>stmt，应该先分析条件，生成midcode，在处理stmt，所以需要在递归下降的时候手动调整代码顺序
    * continue是到label2，break是到label3，需要仔细
    * 全局寄存器的load和save需要进一步优化，否则会被这个优化给放大导致负优化

  * 关于**比较类运算**实现

    原本，我处理< <= > >= == != !时，都采用的是slt, beq，j这三条语句的组合，把最终结果赋到一个临时变量里返回。在与同学交流后，发现实际上mips有对应的语句，但是基本上每一条都是由三条左右的运算指令，可能实际上的运算效率与我原来的设计相差不大。尤其是对于<= 和>=这两条指令，等于情况的发生是很少的，所以运用跳转反而可以节省指令条数。最后只是改写了 ！和 !=

  * 首先是在加减等运算指令里充分考虑了立即数，比如add指令当有常数作为操作数的时候可以变为**addi**，可以节省一个li操作

  * **if-else**在没有else的情况下可以减少一次跳转

  * condExp由于考虑了**短路**，当没有|| 和 &&的情况下会多出两个跳转和label，将其优化掉了（效果特别好）

  * 之前是一个个地把函数声明给跳过，之后改成了直接跳到main函数位置

  * 将运算使用的寄存器减少到了三个

#### 块、数据流（5分）

​	显然，这是优化的基础。基本上所有的优化都需要基于基本块的划分与数据流分析，所以必做

* **基本块的划分**

  首先设计了**基本块的数据结构**，并且对于中间代码进行分析，如果有碰到GOTO， BZ， BNZ， CALL， RET等跳转语句，其下一句就是基本块的开始，碰到LABEL， FUNC语句，就为基本块的开始。

  ```cpp
  class Block{
  public:
      int number;						//块的序号
      int start;						//块的起始中间代码序号
      int end;						//块的结束中间代码序号
      int nextBlock1;					//下一个块的序号
      int nextBlock2;					//下一个块的序号
      vector<midCode> midCodeVector;	//中间代码
      set<string> use;				//use集
      set<string> def;				//def集
      set<string> in;					//in集
      set<string> out;				//out集
  };
  ```

* **流图**的构建

  流图本质上只用看每一个块的起始语句和终止语句，找到跳转的目的块，设置好nextBlock序号即可。最后我将面函数最后的exit块拿出来，并且将每一个函数的return结尾的块都设置为了exit块。这体现了基本块是相对于单一函数而言的性质。

* 数据流分析（**活跃变量分析**）

  * **use def**

    对于每一个块来说，我完全按照理论课上所讲的定义，定义先于使用的变量放入def集，使用先于定义的变量放入use集

  * **in out**

    in out的处理也和书中的一致，前一个块的out是后面所有块的in的∪，块的in是块的out∪use-def

  循环计算直至没有变化，至此我们就将流图和数据流分析完成了。由于到达定义分析要以每一句为单位，更为繁琐，且时间所剩不多，所以我便没有分析。

#### 临时寄存器分配（4分）

​	寄存器分配相关工作都必做，但是由于其较为玄学，可能会在默写情况下频繁访存，产生负优化，所以需要极度小心，细致

*（临时寄存器定义：由于运算赋值而多产生出来的，只使用两次的变量）*

* 首先在生成中间代码的时候我将这类变量**更改了名字**，统一命名为ins_xxx，用于和真实的局部、全局变量进行区分。

* 其次考虑到其瞬时性，共用性，我只将**$t3, $t4, $t5**三个寄存器分配给了这部分变量进行使用，实际效果已经完全够用。

* 采用了FIFO和**临时寄存器池**的思想，由于临时变量会先被定义，后被使用，所以在Lval出现就分配，Rval出现就回收

  ```cpp
  //中间变量
  string insReg[3] = {"$t3", "$t4", "$t5"};
  bool insRegUse[3] = {false, false, false};
  string insRegVar[3] = {"", "", ""};
  
  //查找空中间变量寄存器
  //返回序号，-1无
  int findAvaInsReg() {}
  //第一次出现的ins_xx 分配Reg
  string putIns(string ident){}
  //查看ins_xx 是否已经分配了Reg 回收
  string getIns(string ident){}
  //$t3, $t4, $t5中间变量使用
  void changeIns2Reg(){}
  ```

* 当跨越基本快时，如果有寄存器仍未被回收，则**写回内存**中。

#### 全局寄存器分配（4分）

全局寄存器的分配真的是很难，经历了重构。最开始由于我已经有了数据流的信息，很自然的我就想到了直接设置一个全局寄存器池，对于一个基本块的变量，直接申请即可，在块的最开始从内存中load进寄存器。但是之后我发现如果在每个基本块都进行全局寄存器的重新分配，由于有while和if-else等控制流的存在，正确性根本无法保证。所以之后我还是考虑采用了**引用计数**，对于每一个function内部，其全局变量的分配保持不变。

* 首先统计了可以用于分配的寄存器：
* $v1,$k0,$k1,$t6-9, $s1-7共14个

```cpp
//func：一个变量出现一次
void varAddTimes(string varIdent) {}					//用于统计函数内变量出现次数
//func：变量使用次数
void calFuncVarTimes(int beginBlock, int endBLock)  {}  //用于统计函数内变量出现次数
//func：分配全局寄存器
void disGlobalReg() {}								    //针对一个函数分配全局寄存器
//func: 找对应的GReg
string getGReg(bool isDef, string varIdent) {}          //midcode中的变量找到对应寄存器
//func：改写midcode
void changeGlobalReg(int beginBlock, int endBLock) {}	//修改函数的midcode
//引用计数全局寄存器分配
void changeGlobal2Reg() {}								//总函数
```

至此，我们已经可以将midcode中的变量替换为全局寄存器，但是仍有一下的**注意点**需要考虑，来保证正确性

* 首先需要在函数头，将分配的全局寄存器中的**全局变量**和**函数参数**（不包括前三个）load进入寄存器。

* 函数调用前将被改写过的变量写回内存，考虑了活跃变量和全局变量。

* 函数调用后将变量加载回寄存器中，考虑了活跃变量。

* continue、while等循环内如果有函数调用，需要在返回前save被改变了的变量。否则将会出错

  ```cpp
  int a; //<- $t6 
  while() {
  	func();
      //load a from mem to $t6
      a -= 1;
  }
  ```

#### 原寄存器设计改进等：传参（5分）

​	原来函数的参数传递没有使用寄存器，并且还设计了参数栈。其正确性其实是能够保证的，但是会多很多的访存，并且还会给全局寄存器分配带来压力，所以就按照常规的mips设计规范改了。

* 首先是更改了**函数传参**的方式。

  原来由于在函数调用的时候遇到一个实参会直接立马生成一条PUSH中间代码来传参，这会导致嵌套调用时候参数的归属无法确定，所以只能使用了栈来传参。但是这会使得函数调用时每一个参数都多两条内存操作指令。所以我调整了参数传递和函数调用的指令顺序，只有当分析完所有的参数时才会统一传参，这样就避免了归属问题，自然也就不需要参数栈了，还省下了一个寄存器$s1。

* 其次是把函数的前三个参数放在了$a1, $a2，$a3里

  由于$a0在printf中会被使用，处于简化的考虑，便没有继续使用$a0来传参。对于每个函数来说，其内部对于前三个参数的使用都会被替换为$a1,$a2,$a3，并且在函数调用语句的前后会进行SAVE和LOAD操作，尽管不是最优解，实际上可以统计一下dirty，但是对于代码的优化程度也是很大的。

#### 常量合并、传播（1分）

​	至此，新手红利期的甜蜜基本就被吃完了，之后优化的效果实际上就不是那么明显了。本质上常量合并、传播配合上死代码删除按道理来讲作用应该挺大的，但可能是我只考虑了在基本块内部的缘故吧，居然没有优化效果QAQ，当然了，这也可能是测试点不适合的关系。对于下面的测试点可以看到其效果还是非常好的。

​	常量合并就是对于运算类型的中间代码，如果其操作数是常数，就将其改成一个赋值语句。而复制传播则是如果前面已经得知一个变量是由另外一个变量赋值生成的，则可以在之后出现这个变量的指令中将其全部替换为原先的变量。

​	乍一看实际上这是没什么用处的，减少不了代码的数量，也节约不了性能，可是，如果先前被赋值的变量在之后没有被使用，其便可以被之后的死代码删除所优化掉，就例如下面这个例子:


```cpp
int main() {
    		int a,b,c,d,e,f;
    		a = 1;
    		b = a * a + a;
    		c = a * a * a;
    		d = b * c + b + c;
    		e = d;
    		f = 2 * e + a;
    		printf("%d",f);
}
```

在经历若干遍复制传播，常量合并，一遍死代码删除后，其最终可以被优化为：

```cpp
printf(12);
```

可以看到这三个组合拳结合起来威力还是很大的。

* 常量合并没有什么可说的

* **复制传播我只做了基本快内的**，并没有去做到达定义分析，处理块之间的，其处理流程如下

  * 只有ASSIN类的赋值语句会形成新的映射。

    形成新的映射实际上就是在一个map钟加入新的元素。

  * 所有对于变量有改变的语句都需要判断改变映射。

    改变映射则需要考虑，对于已经存在的映射中，要尽最大努力保留原先的映射关系。

    ```cpp
    假如新加入了 a = b <a,b>
    map中原本有 c = a <c,a> 和 a = d <a,d>
    则这两条映射都会被删掉，但是隐含的 c = d <c,d>则需要被添加，再加上 a = b <a,b>，从而形成新的映射关系集合
    ```

#### 死代码删除（3分）

​	有了活跃变量分析，死代码删除就是水到渠成的了。对于一个基本块来说，朴素的思想就是当一个赋值语句的Lval变量并不是活跃变量，就可以考虑将这条语句删除。但是实际上仍然有更多的细节需要去考虑。

* 首先就是全局变量的赋值是不能删除的，因为数据流是函数内部的分析，无法得知其他函数是否使用了该全局变量。

* 其次是out集指出了之后该变量的使用情况，**但是在一个块内，变量的使用仍然需要被考虑**。考虑如下的情况：

  ```cpp
  //block begin
  variable_1 = $t5;
  variable_2 = variable_1 + variable_3;
  //block end
  
  no use of variable_1, use of variable_2
  ```

  我们也是不应该将变量1的赋值语句删除掉的，所以当我们遍历一个块并去寻找死代码时，要从后向前遍历，出现在Rval的变量要存起来以供查询。

#### 运算强度削弱：除法（0分）

​	除法设置成100个cycle很显然就是想让我们去优化的，但是我却惊奇的发现不管是看往届学长学姐的代码还是和同学交流，除法的操作空间好像不是那么大。

​	最有效的方式是将除法指令转化为乘法指令，其原理如下：

  ```cpp
  A / B = A * k / B * k
  	若B * k = 2 ^ n, 则A * k = 2 ^ n ，则
  A / B = A * k >> n。
  所以对于 A / B, 只需找到一个k，使得 除数*k等于一个二的幂，并计算出n来移位即可
  ```

  原理十分易懂，但其有一些缺点：

  * 由于不能精确地使其变成二的幂，所以有一些上下取整的问题
  * 只能处理常数（K需要编译器来计算）

  由于与同学交流后发现其很容易产生bug，且时间不够，就没有来得及加上

* 所以最终只做了如下的优化：

  ```cpp
  x / 2^n = 
  		srl $a0, $s1, 31
  		addu $t0, $s1, $a0
  		sra $t3, $t0, 1
  x / -2^n = 
      	srl $a0, $s1, 31
  		addu $t0, $s1, $a0
  		sra $t3, $t0, 1
      	subi $t3, $zero, $t3
  0/x=0，x/1=x
  ```

没有效果QAQ（这测试样例也太刁钻了吧？

#### 没做但是觉得应该做的优化

* 首先是**函数内联**，函数调用的开销实在是太大。如果想要尽可能地规避开销，一定要把内联给写上。但是我的架构并不允许新开辟变量区了，如果要实现的话需要对架构进行大改，想了想还是算了
* 其次是**除法**，肯定可以进一步优化，而方法就是上面所讲的，也实在是没体力优化了
* 最后是**循环外提**，估计很有用，但是我没搞到达定义，也算了

### 总结感想

**——曾经沧海难为水，除却巫山不是云**

​	转眼间，编译课程就要结束了，回顾这一个学期的编译之路，真的是感慨万千。一次次的迭代，一共写了大约6000行的代码，成就感满满。之前写过的最难的程序，也不过是上学期的OO，但那时候三次一个小项目也不过最多仅仅3000行。而编译器，真的是一个大项目，从头到尾，助教仅仅是给了我们设计文档，也不是很详细，更多的细节都需要我们自己去思考、设计。

​	回顾最终的代码，真心感觉是九死一生。从最开始的程序分析、词法分析的不屑一顾，到之后语法分析的初具规模，到之后错误处理的熬夜爆肝，再到超级大boss——代码生成的斩妖除魔，再到代码优化的重见光明。看着我自己亲手生成的中间代码文档，看着我自己生成的mips代码文档，我简直母爱泛滥。将一个c语言程序通过我的努力生成了汇编语言，如果应用在我大二做的cpu上，他是真的可以跑出来结果的。从上到下，编译完成了三大重课的临门一脚，将整个体系串联了起来。

​	看着代码生成的1500行代码，我真心觉得好不容易。我基本上是自己把mips架构设计了一遍。
​	还记得那时一个周六，我下午在图书馆坐着，就干坐着，我知道我现在应该写编译作业，ddl快到了，但是无从下手。助教说要设计中间代码，生成中间代码，输出中间代码，怎么设计？没有参考。助教说要生成mips汇编，还要能够短路，能够读值，能够输出，需要使用那些指令？没人告诉我。函数调用的时候应该生成什么？我的变量怎么分配？mips的内存空间可以使用哪些地方？is-else、while等等的控制流该怎么去处理？寄存器呢，我该什么时候去分配？什么还要优化，是不是要一开始就把架构弄好？常量被取用他的值也要传递，但我是递归下降没法搞啊？函数传参有的是赋值有的是引用，这怎么区别？………………

​	做了一下午，又做了一周日，又做了一个周一，没有进度。同时面对如此多的问题，我不知道如何将他们同时处理。可能这就是工程的难题吧，问题是互相耦合的，有点像鸡生蛋蛋生鸡的问题，很难理出一个完美的拓扑序。而有的时候，最好的破局方法实际上就是直接挑一个点硬做。这就有点像循环体数据流分析的过程，你总得想找一个地方分析，再一圈圈分析，迭代出完美的正确解。总而言之，不放弃。面对着架构无法处理递归程序情况，我对书中的函数栈的作用恍然大悟；当我认识到传参原来开销这么大时，我明白mips使用四个寄存器传参的用意；当我被一次函数调用带来的巨量代码所震惊时，我明白了函数内敛的意义。

​	重新回顾我大一的c语言代码，我的视角早已发生了变化。我会思考函数参数背后的传递机理，我会思考此处的代码实际上完全没必要，gcc会不会帮我自动给删了呢？我会思考可能我写代码时候迷迷糊糊，但实际上编译器才是那个最懂我的人。看到除法，我会心生恐惧，看到while，if-else我更会去寻找控制流。哪怕是那小小的printf，都会勾起我对于.global以及内存架构的回忆。

​	当然，知识本身其实并不重要，这就好比大二我上完计算机组成，那已经觉得这辈子不会再忘mips架构了，但是是过一个月就基本什么细节都不记得了。编译可能也是一样，可能寒假过后，什么错误处理，什么优化我都会记不太清。但是他让我对于代码有了全新的理解，让我对我的能力有了全新的评估，让我熟悉些日志帮助我更好的迭代开发，帮助我第一次主动使用github进行版本控制，帮助我明白，原来简简单单的c语言，一句"hello word"背后要有这么多的工作，原来以前的计算机科学家面对的科研是如此的富有挑战性，原来理论真的可以指导实践，原来书上的东西真的可以落实成代码。

​	而近两周时间的代码优化经历又告诉我，当我们面对困难，急需提高的时候，其实改进自己原有的问题时更加务实的，不要对于自身的问题有惧怕心理，懒惰情绪，要学会勇敢面对。当我优化不动时，总幻想着能不能找一个更先进的优化方法一飞冲天。可之后才发现，仅仅是把自己原有的冗余代码优化掉就可以前进一大步，从自己身上寻找问题，才是捷径。当然，优化就意味着debug，并且是cpp，c，midcode，mipscode的多线程互看，体验非常糟糕。

​	总而言之，本学期的编译课体验不错，感谢助教和老师们的陪伴与付出。当然，下面还有一些建议。

#### 建议

* 首先是优化部分，我认为或者可以缩短时间，减少恶性竞争与边界效应；或者可以设定一个阈值，过了线即拿到大部分分数。（当然这也会让课程在知乎少一些口诛笔伐）
* 其次是理论部分，令人惊诧的是居然老师和助教从始至终没有给出来过具体的考点范围，这使得复习范围很大，且重点不够明显
* 最后是上机课的时间其实可以组织同学们互相交流展示，以换取平时分，这样也能答疑解惑一下，毕竟助教们都很久不写编译，对于mips体系不是很熟

