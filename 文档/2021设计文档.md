## 2021设计文档

### 总架构

* 首先调用lexical.cpp的**词法分析程序**，生成**token列表**。之后使用error.cpp中的**错误处理**程序和error_grammar进行**错误分析**，单独处理错误。使用mips_grammar在**递归下降**中调用midcode.cpp**生成中间代码**。接着使用optimize.cpp面向中间代码进行**优化**，之后调用mipsCode.cpp和符号表生成**mips代码**。

### 词法分析

#### 设计思路

* 采用课本上的自动机的思路，使用if-else和switch的选择结构对于每一种情况分别讨论。将自动机转化为while或者for循环的结构，以单词为一个单位做个分析，输出至文件（存储在数据结构中）。

* **结构**

  分为main.cpp，lexical.cpp，lexical.h 的结构。

  **main文件**负责文件的读取，调用头文件中的函数。

  **头文件**将主分析程序的函数提出来方便调用。

  * 一个token的数据结构如下：

    ```cpp
    struct CompSymbol{
        int symbol = 0;
        std::string stringContent;
    };
    ```
  
  **主分析程序**主要分为五个部分：
  
  * 首先是变量的声明以及种类库的枚举。
  
    将Token以enum形式完全枚举了出来，并且将需要识别的保留字字符串提前写好。声明了symbol(Token)，index(offset)等等关键变量。
  
  * 其次是基本识别函数。
  
    对于所有字符的识别，都依次拆分成了一个个布尔值的函数，以防止主函数内容过多。
  
  * 之后是基本遍历函数。
  
    对于每一个循环单位，我们需要识别出一个字符串的种类，也就是对应着一行输出。所以我们需要对取字符，字符串拼接，字符回退等等基本操作完成书写。
  
  * 再之后是主分析函数。
  
    对于每一种Token都使用了if-else来分别分析，最终把需要输出的Token放在symbol中，把字符串、常量、变量名储存以便于输出。
  
  * 最后则是输出函数。
  
    对于Token使用了switch-else结构来分别输出对应的信息至文件。

#### 额外注意点

* 注释

  需要针对//和/*的主食结构分别讨论，再加上本来的div含义，这三种情况的分类要注意避免杂糅

* 字符串输出

  对于char[]类型的字符串，当使用cout流式输出时，要注意字符串的尾部需要加上一个'\0'

#### BUG

* 对于回退（retract）一定要仔细。否则输出信息极易被丢失。

### 句法分析

#### 设计思路

* 递归下降的设计思路，将每一个对象表示为了一个**函数**，负责该非终结符的处理。并且保持了**约定**，进入一个对象时，第一个字符已经被读好，离开时要输出该对象的信息并且预读下一个字符。由于顺序读取需要处理两个的预读，所以采用了读两遍的策略，重新读取词法分析输出的token序列。

* **结构**

  大体可以分为两部分。

  * 第一部分是分支的预测函数，由于已经有了全部的token序列，所以可以很方便地对其跳跃分析，预测分支走向；
  * 第二部分是对应每一条文法的函数，其目的就是分解文法左端的非终结符，递归向下分析，并且将token信息和非终结符信息输出。

#### 额外注意点

* 预读的问题。

  由于按照书上的预读策略，所以需要处理好token的打印归属问题。token预读的时候是不能输出的，否则会产生归属错误的情况。所以我设计了三个函数（效率不高），分别是只读不输出，同时读和输出，只输出，来配合完成任务。

  但是之后我又想，预读的策略目的是一遍便可以完成所有branch，既然我是两遍，预读本身就是没有意义的，所以这一点上设计出现了问题

#### BUG

* 文法理解错误：左递归消除后输出不一样，不能直接拆分
* 预读不能输出（顺序问题）采用了三个函数共同处理
* 注释相关的丢舍（实际上是和词法分析的配合）

### 错误处理

#### 设计思路

* 通过跟学长、助教、同学们的交流，发现这一次的架构大概分为两类：第一类是需要在语法分析的层次上将AST（抽象语法树）完全显式地建出来，则之后的错误处理，以及一系列的过程都可以在这颗树上完成，减少了耦合度，有了中间结果，属于是很理想的方案。第二类是将错误处理与原来的语法分析写在一起，此时语法分析更像是一个过程而不是一个步骤，之后的所有步骤都将建立在这个“递归下降”的过程中，一个c文件将搞到几千行。

* 显然第一种是更加优秀的架构，但是考虑到此次作业较为冗杂，过程化，对于AST的依赖并不高；并且，我还并不清楚AST的具体实现方式，需要继续观察、交流，所以我考虑这一次将错误处理按照第二种方式处理，毕竟之后并不需要迭代这个步骤，所以可以在之后进一步建树（如果有需要的话）。

* **结构 **

  ​	将错误处理与原来的语法分析写在一起，此时语法分析更像是一个过程而不是一个步骤，之后的所有步骤都将建立在这个“递归下降”的过程中。由于错误处理相对独立，并且我的中间代码生成实际上也是写在“递归下降”的过程中，耦合过于严重，于是我就粗暴的将错误处理单拎出来来递归下降一遍，如果没有报错则进行接下来的的步骤。所以出现了error_grammar.cpp和mips_grammar.cpp两个语法分析文件。

  * **Error.cpp**

    放置所有自己定义的错误类ErrorA到ErrorM，以及识别格子错误的函数lookErrorA到lookErrorM，针对每一类的错误完成识别并报错，输出错误信息到文件。

  * **符号表**

    由于错误中出现了关于函数和变量的查询、判断，我们需要建立一个符号表，以识别当前的作用域，有效的变量，目前所在的函数等信息。符号表的建立采用了最为经典的方法：声明了唯一的全局变量level以记录当前的层级（本质上为作用域），在遇到函数、参数、变量时完成的那个对于符号表的更新；在退出一个作用域时完成对于符号表的删减。由于变量和函数的名称可以相同，所以我将函数和变量分开存储在了两个表中。
  
    ```cpp
    enum vfType{
        Int, Void
    };
    struct var{
        string ident;
        int type;
        bool isConst;
        int dim = 0;        //此处value有缺陷    //对应数组维数
        int level;
    };
    struct func{
        string ident;
        int type;
        int returnType; //-1无return，0return，1return int
        vector<var> params;
    };
    // 符号表相关
    vector<var> varTable;
    vector<func> funcTable;
    ```

#### 额外注意点

* 此次需要额外注意的错误有以下几个：E、（IJK）、J
* **E**需要去将函数调用中的实参分别和函数定义的形参完成比较，分析其是否类型一致。但是由于实参定义为EXP，最终可以递归到数字、变量、函数调用，EXP**嵌套**的组合上，无法直接判断其类型。所以我将涉及到的递归子函数的返回值赋予了变量维数的意义，逐级分析返回，最终给出分析Rparam的类型。
* **IJK**三个函数需要判断;)]这三个符号的缺失，属于语法分析维度。但由于递归下降的过程默认了他们的存在，当他们缺失时，会与原来的识别步骤产生矛盾。所以当我们发现它缺失报错后，需要默认他存在继续接下来的分析程序，以确保语法分析的完整性。
* **J**是识别)，其涉及到了 Ident '(' [FuncRParams] ')' 这条语法规则，可以看到当）缺失时我们需要判断是否存在 [FuncRParams] 这一非终结符，其决定了我们程序的走向。所以我使用理论课学习的First集知识和行号判断，进行了识别。

#### BUG

* CPP相关

  写java写顺手了函数传参一开始写成值传递了，错了很多。之后反应过来进行了引用传递。

* 上文提到的额外注意点，都错过

* error.txt的输出错误

  行号输出不尽相同，需要我们分别传参处理

### 代码生成

#### 设计思路

* 大体思路是在**递归下降**的过程中直接完成**中间代码**的生成，之后根据**符号表和中间代码**完成对于**MIPS汇编代码**的生成。

* **符号以及变量**的处理：

  * 中间代码阶段的符号名是应该被统一的，否则没有办法解决重名的问题。又由于函数中的变量实际上都需要在函数栈中新开空间，所以符号表要记录变量相对于函数的地址偏移。因此数组变量的维数、大小都需要被记录。另外我们还要区分全局变量，这一点也要体现在符号表中。最后其嵌套层数，当前是否可用等信息也要被记录。所以符号涉及结构如下：

    ```c++
    struct Variable{
        int num;
        string rName = "";
        string fName = "";
        int dimCount; //0 1 2
        int dim[2];
        int level;
        bool valid;
        int address;
        string func = "";
        vector<string> value;  //存const的初值 var不存
    };
    ```

* **递归下降**：

  * 由于MIPS的特性，所有的string类型都应该被存储在.asiicz中，这意味着我们需要在递归下降的过程中完成字符串常量的存储。
  * 另外由于C++的返回值传输比较费劲，所以这是一个极大的难点，之后会进一步讨论。由于降低耦合等缘故，我把错误处理模块分出去变成了一个单独的“遍”，这样返回值也不会和生成中间代码有所冲突。
  * 设计了两个函数addNewVariable()和addNewLabel()用以生成新的标号的中间变量和label，可以生成新的运算使用的中间变量，也可以吧声明过得原符号转换成新的名称存入符号表，之后中间代码就会使用新的符号名。

* **中间代码**的处理

  * 中间代码采用了四元式的模式进行处理

    ```c++
    class midCode {  //z = x op y
    public:
        operation op; // 操作
        string z;     // 结果
        string x;     // 左操作数
        string y;     // 右操作数
    }
    ```

  * 部分op符号如下所示：

    ```cpp
    enum operation {
        PLUSOP, //+ z x y
        ……
    
        ASSIGNOP,  //= z x
    
        //z:label
        //x:op
        GOTO,  //无条件跳转 z
        BZ,    //为0跳转 z x
        BNZ,   //为1跳转 z x
        LABEL, //标号 z
    
        PUSH,  //函数调用时值传递 z:ident x:dim
        PUSHADDR, //函数调用时地址传递 z:ident x:offset y:要传到第几个
        CALL,  //函数调用 z:func_ident
        RET,   //函数返回 z:var_ident
        RETVALUE, //函数返回值赋值 z:ident x:RET
    
        SCAN,  //读 z:ident
        PRINTD, //写 z:ident
        PRINTS, //写 z:string_ident x:string_content
    
        CONST, //常量 z
        CONSTARRAY, // 常量数组 z
        ARRAY, //数组声明 z
        VAR,   //变量 z
    
        FUNC,  //函数定义 z:type x:ident
        PARAM, //函数参数 z:ident
        GETARRAY,  //取数组的值  z:ident x:ident y:offset
        PUTARRAY,  //给数组赋值  z:ident x:offset y:ident
        EXIT,  //退出 main最后
        
        SAVE, //寄存器sw z:reg_ident x:ins_ident
        LOAD, //寄存器lw z:reg_ident x:var_ident
    };
    ```

    大部分符号的含义和结构都注释出来了，跳转指令只有三个，所以需要将Cond的值计算成一个Variable来进一步判断，函数调用相关的操作传值和传地址要分开，但是都是传到栈里，声明操作仅仅是为了增加中间代码的可读性（方便debug）并没有实际用途，数组相关的取值赋值操作一定要单独出来，因为offset的缘故其和assign是有区别的。

  * 还另外设计了一个输出中间代码的函数outPutMidCode()，用来将中间代码输出到文件中，方便检查以及后续的优化。

* **MIPS汇编代码**的生成

  * 拿到了从中间代码生成模块产生出来的中间代码序列后，我们要做的就是将中间代码再翻译一次，翻译成汇编。在这一部分里，相比于中间代码生成的直接了当，我们则需要多考虑一下mips的特殊性：地址分配，参数传递，语言规范等等。相比起原先的顺序翻译，我们这一次还要在设计中考虑到mips的执行过程顺序问题：函数声明需要跳过，main函数return的特殊性等等。

  * 汇编代码由于有立即数的参与所以设计成了五元式：

    ```cpp
    class mipsCode {
    public:
        mipsOperation op; // 操作
        string z;     // 结果
        string x;     // 左操作数
        string y;     // 右操作数
        int imm;     // 立即数
    };
    ```

    相比中间代码操作符支持符号、数字混用，mipsCode的数字一定要放在立即数中

  * 使用的部分mips指令如下所示：

    ```cpp
    enum mipsOperation {
        mips_add,    //add $s1, $s2, $s3
        ……
    
        mips_slt,    //slt $s1, $s2, $s3
        mips_beq,    //beq $s1, $s2, label
        mips_bne,    //bne $s1, $s2, label
        mips_j,      //j Loop_End
        mips_jal,    //jal my_function_name
        mips_jr,     // jr $31
    
        mips_lw,     //lw $v1, 8($sp)
        mips_sw,     //sw $v1, 8($sp)
        mips_syscall,
        mips_li,     //li $t1, -1
        mips_la,     //la $a0, head
        mips_move,   //move $t0, $t1
    
        mips_dataSeg,  //.data
        mips_asciizSeg, //.asciiz
        mips_textSeg,  //.text
        mips_label,  //产生标号
    };
    ```

    值得注意的是，所有的 < > <= >= != == GOTO 操作我全部使用上面的六条跳转指令完成。

  * mips体系相关：

    * 寄存器分配

      ```
      /*
       *  $gp不变，存储全局变量,从低到高
       *  $sp函数尾,$fp函数头 运行栈（从低到高）：栈长、返回绝对地址、参数、局部变量
       *  $ra函数ret
       *  $a1, $a2, $a3 函数传参用
       *  $t0, $t1, $t2 运算用
       *  $t3, $t4, $t5 ins_Var 中间变量使用
       *  $t6,$t7,$t8,$t9,$s1,$s2,$s3,$s4,$s5,$s6,$s7,$v1,$k0,$k1 var_Var 跨基本块变量使用
       *  $a0, $v0 与 syscall使用
       *  $s0 函数返回值
       *  hi, lo
       */
      ```

      最初采取的是寄存器的暴力分配，仅仅手动地调用了上述寄存机参与运算，并且处于简便的目的，**所有的变量都对应着内存中的唯一地址**，使用、赋值都需要使用sw，lw操作对应的内存空间。我还将全局变量（常量）存储在了$gp寄存器的上边。~~函数参数栈从0x1004000(堆)开始，$s1标志着函数参数栈的栈顶~~ （后来抛弃了这一设计），函数栈的调用、标志、区分使用了$sp、$fp两个寄存器，从$sp从上向下存储，但是为了使得数组的元素存储顺序和$gp区域的全局变量一致，采用了如下的存储方式: $fp(函数栈头) - 函数长度 - 函数返回值 - 临时变量头 - 临时变量尾 - $sp(函数栈尾)。

    * 函数传参及使用的过程如下：

      ~~调用的时候将变量的值或者地址传进参数栈里，调用函数的时候反序从栈里面取出来~~ （后来抛弃了这一设计）。如果函数内部要使用传进来的数组，需要先使用地址，寻址将真实值取出（修改），间接完成对于函数外变量的操作。
    
    * 使用了mipsCodeOutput()函数，将mips代码输出至文件中。

#### 难点

* 递归下降时候的数据传输。

  * 产生这个难点的原因是因为由于全局数组的大小，全局变量的初值都是常量表达式，又因为mips的时候需要提前分配空间，数组的定义很可能会依赖与另外一个数组等等原因，需要我们在编译期就将常量表达式计算出结果。又由于在递归下降中，数据的传输又是通过返回值进行的，所以此处的设计就显得异常的艰难。

  * 我将函数的返回值都定义为了string类型。返回值的可能类型有三种：<variable, NONE> / <number, NONE> / <ident, offset>，分别为变量名、数字、地址（相对变量偏移）。在需要使用返回值的函数中，会对于返回值进行判断、解析、运算、输出。

  * 数据传输的艰难尤其体现在了LVal的处理上：

    LVal有可能是左值(赋值)，也有可能是右值(取值)，左值需要返回的是变量名或者是地址，右值则完全不确定。

    首先能取出来数的一定要取出来，但是这涉及到了：变量是否有初值，偏移是否是常数，偏移和变量的维数关系等等，写的时候极其费劲，最终由大量的 if-else , switch组成，虽然不是很干练，但是将情况基本覆盖了。
    
    ```cpp
    bool isAllNumber(vector<string> list){}
    string LValGetVAlue(string ident, vector<string> indexs){}
    string LValGetLeft(string ident, vector<string> indexs){}
    string LVal(bool isGet){}
    ```

#### BUG

* 直接将写的时候的记录日志贴上来了：

  ```cpp
  begin date: 11/7/2021
  
  author: mwt
  date: 11/12/2021
  tittle: midcode check
  改过的BUG：
  	&v
  	变量不存value（splitAssgin删除）
  	funvTable越界
  	把getoffset改成了返回string
  	取值生成数组offset使用了merge
  	函数加一个手动return
  	&v在vTable扩容的时候会变
  	
  author: mwt
  date: 11/14/2021
  tittle: mipscode check	
  做了的：
  	函数声明区间第一次应该跳过，而main不用，其ret0时应该检查后一句是否为exit
  	isnumber忘了+—号
  	函数调用ra覆盖（变量gp，栈sp）
  	pushAddr*2 getArray putArray ret call
  	vTable valid小错
  	
  author: mwt
  date: 11/16/2021
  tittle: 内存重构
  做了的：
  	函数嵌套调用min(r, scan())传参：栈
  	break continue 小错
  	把函数栈变量顺序颠倒了一下
  	lvalget小bug
  	
  author: mwt
  date: 11/18/2021
  tittle: A组点
  做了的：
  	短路求值
  	main支路RETURN不返
  	<=溢出 改了leq geq
  
  ```



### 代码优化

#### 大体思路

* 代码优化大致分为两部分
  * 一是对于原来架构设计的改善，部分语句的缩减，属于是“**改正**”。
  * 二是使用理论课中学习过的优化方法进行优化，属于“**优化**”。
* 代码大部分位于**optimize.cpp**中，针对于中间代码和目标代码直接进行优化。

#### 改正

* 首先是更改了**函数传参**的方式。

  原来由于在函数调用的时候遇到一个实参会直接立马生成一条PUSH中间代码来传参，这会导致嵌套调用时候参数的归属无法确定，所以只能使用了栈来传参。但是这会使得函数调用时每一个参数都多两条内存操作指令。所以我调整了参数传递和函数调用的指令顺序，只有当分析完所有的参数时才会统一传参，这样就避免了归属问题，自然也就不需要参数栈了，还省下了一个寄存器$s1。

* 其次是把函数的前三个参数放在了**$a1, $a2，$a3**里

  由于$a0在printf中会被使用，处于简化的考虑，便没有继续使用$a0来传参。对于每个函数来说，其内部对于前三个参数的使用都会被替换为$a1,$a2,$a3，并且在函数调用语句的前后会进行SAVE和LOAD操作，尽管不是最优解，实际上可以统计一下dirty，但是对于代码的优化程度也是很大的。

* 关于**比较类运算**实现

  原本，我处理< <= > >= == != !时，都采用的是slt, beq，j这三条语句的组合，把最终结果赋到一个临时变量里返回。在与同学交流后，发现实际上mips有对应的语句，但是基本上每一条都是由三条左右的运算指令，可能实际上的运算效率与我原来的设计相差不大。尤其是对于<= 和>=这两条指令，等于情况的发生是很少的，所以运用跳转反而可以节省指令条数。最后只是改写了 ！和 !=

* 杂七杂八（大多是**冗余删减**）
  * 首先是在加减等运算指令里充分考虑了立即数，比如add指令当有常数作为操作数的时候可以变为**addi**，可以节省一个li操作
  * **if-else**在没有else的情况下可以减少一次跳转
  * condExp由于考虑了**短路**，当没有|| 和 &&的情况下会多出两个跳转和label，将其优化掉了（效果特别好）
  * 之前是一个个地把函数声明给跳过，之后改成了直接跳到main函数位置
  * 将运算使用的寄存器减少到了三个

#### 优化

##### 临时寄存器划分

*（临时寄存器定义：由于运算赋值而多产生出来的，只使用两次的变量）*

* 首先在生成中间代码的时候我将这类变量**更改了名字**，统一命名为ins_xxx，用于和真实的局部、全局变量进行区分。

* 其次考虑到其瞬时性，共用性，我只将**$t3, $t4, $t5**三个寄存器分配给了这部分变量进行使用，实际效果已经完全够用。

* 采用了FIFO和**临时寄存器池**的思想，由于临时变量会先被定义，后被使用，所以在Lval出现就分配，Rval出现就回收

  ```cpp
  //中间变量
  string insReg[3] = {"$t3", "$t4", "$t5"};
  bool insRegUse[3] = {false, false, false};
  string insRegVar[3] = {"", "", ""};
  
  //查找空中间变量寄存器
  //返回序号，-1无
  int findAvaInsReg() {}
  //第一次出现的ins_xx 分配Reg
  string putIns(string ident){}
  //查看ins_xx 是否已经分配了Reg 回收
  string getIns(string ident){}
  //$t3, $t4, $t5中间变量使用
  void changeIns2Reg(){}
  ```

* 当跨越基本快时，如果有寄存器仍未被回收，则**写回内存**中。

##### 基本块和流图以及数据流分析

* **基本块的划分**

  首先设计了**基本块的数据结构**，并且对于中间代码进行分析，如果有碰到GOTO， BZ， BNZ， CALL， RET等跳转语句，其下一句就是基本块的开始，碰到LABEL， FUNC语句，就为基本块的开始。

  ```cpp
  class Block{
  public:
      int number;						//块的序号
      int start;						//块的起始中间代码序号
      int end;						//块的结束中间代码序号
      int nextBlock1;					//下一个块的序号
      int nextBlock2;					//下一个块的序号
      vector<midCode> midCodeVector;	//中间代码
      set<string> use;				//use集
      set<string> def;				//def集
      set<string> in;					//in集
      set<string> out;				//out集
  };
  ```

* **流图**的构建

  流图本质上只用看每一个块的起始语句和终止语句，找到跳转的目的块，设置好nextBlock序号即可。最后我将面函数最后的exit块拿出来，并且将每一个函数的return结尾的块都设置为了exit块。这体现了基本快是相对于单一函数而言的性质。

* 数据流分析（**活跃变量分析**）

  * **use def**

    对于每一个块来说，我完全按照理论课上所讲的定义，定义先于使用的变量放入def集，使用先于定义的变量放入use集

  * **in out**

    in out的处理也和书中的一致，前一个块的out是后面所有快的in的∪，块的in是块的out∪use-def

  循环计算直至没有变化，至此我们就将流图和数据流分析完成了。

##### 常量合并与复制传播

​	经过阅读学习上一届学长们的申优文档，我得知常量合并和复制传播配合死代码删除是非常有效的。常量合并就是对于运算类型的中间代码，如果其操作数是常数，就将其改成一个赋值语句。而复制传播则是如果前面已经得知一个变量是由另外一个变量赋值生成的，则可以在之后出现这个变量的指令中将其全部替换为原先的变量。

​	乍一看实际上这是没什么用处的，减少不了代码的数量，也节约不了性能，可是，如果先前被赋值的变量在之后没有被使用，其便可以被之后的死代码删除所优化掉，就例如下面这个例子:


```cpp
int main() {
    		int a,b,c,d,e,f;
    		a = 1;
    		b = a * a + a;
    		c = a * a * a;
    		d = b * c + b + c;
    		e = d;
    		f = 2 * e + a;
    		printf("%d",f);
}
```

在经历若干遍复制传播，常量合并，一遍死代码删除后，其最终可以被优化为：

```cpp
printf(12);
```

可以看到这三个组合拳结合起来威力还是很大的。

* 常量合并没有什么可说的

* **复制传播我只做了基本快内的**，并没有去做到达定义分析，处理块之间的，其处理流程如下

  * 只有ASSIN类的赋值语句会形成新的映射。

    形成新的映射实际上就是在一个map钟加入新的元素。

  * 所有对于变量有改变的语句都需要判断改变映射。

    改变映射则需要考虑，对于已经存在的映射中，要尽最大努力保留原先的映射关系。

    ```cpp
    假如新加入了 a = b <a,b>
    map中原本有 c = a <c,a> 和 a = d <a,d>
    则这两条映射都会被删掉，但是隐含的 c = d <c,d>则需要被添加，再加上 a = b <a,b>，从而形成新的映射关系集合
    ```


##### 死代码删除

​	有了活跃变量分析，死代码删除就是水到渠成的了。对于一个基本块来说，朴素的思想就是当一个赋值语句的Lval变量并不是活跃变量，就可以考虑将这条语句删除。但是实际上仍然有更多的细节需要去考虑。

* 首先就是全局变量的赋值是不能删除的，因为数据流是函数内部的分析，无法得知其他函数是否使用了该全局变量。

* 其次是out集指出了之后该变量的使用情况，**但是在一个块内，变量的使用仍然需要被考虑**。考虑如下的情况：

  ```cpp
  //block begin
  variable_1 = $t5;
  variable_2 = variable_1 + variable_3;
  //block end
  
  no use of variable_1, use of variable_2
  ```

  我们也是不应该将变量1的赋值语句删除掉的，所以当我们遍历一个块并去寻找死代码时，要从后向前遍历，出现在Rval的变量要存起来以供查询。

##### 全局寄存器分配

​	全局寄存器的分配真的是很难，经历了重构。最开始由于我已经有了数据流的信息，很自然的我就想到了直接设置一个全局寄存器池，对于一个基本块的变量，直接申请即可，在块的最开始从内存中load进寄存器。但是之后我发现如果在每个基本块都进行全局寄存器的重新分配，由于有while和if-else等控制流的存在，正确性根本无法保证。所以之后我还是考虑采用了**引用计数**，对于每一个function内部，其全局变量的分配保持不变。

* 首先统计了可以用于分配的寄存器：
* $v1,$k0,$k1,$t6-9, $s1-7共14个

```cpp
//func：一个变量出现一次
void varAddTimes(string varIdent) {}					//用于统计函数内变量出现次数
//func：变量使用次数
void calFuncVarTimes(int beginBlock, int endBLock)  {}  //用于统计函数内变量出现次数
//func：分配全局寄存器
void disGlobalReg() {}								    //针对一个函数分配全局寄存器
//func: 找对应的GReg
string getGReg(bool isDef, string varIdent) {}          //midcode中的变量找到对应寄存器
//func：改写midcode
void changeGlobalReg(int beginBlock, int endBLock) {}	//修改函数的midcode
//引用计数全局寄存器分配
void changeGlobal2Reg() {}								//总函数
```

至此，我们已经可以将midcode中的变量替换为全局寄存器，但是仍有一下的注意点需要考虑，来保证正确性

* 首先需要在函数头，将分配的全局寄存器中的全局变量和函数参数（不包括前三个）load进入寄存器。

* 函数调用前将被改写过的变量写回内存，考虑了活跃变量和全局变量。

* 函数调用后将变量加载回寄存器中，考虑了活跃变量。

* continue、while等循环内如果有函数调用，需要在返回前save被改变了的变量。否则将会出错

  ```cpp
  int a; //<- $t6 
  while() {
  	func();
      //load a from mem to $t6
      a -= 1;
  }
  ```

##### 运算强度削弱：除法

* 对于100个cycle的除法指令，我们显然是应该做些什么的。

* 最有效的方式是将除法指令转化为乘法指令，其原理如下：

  ```cpp
  A / B = A * k / B * k
  	若B * k = 2 ^ n, 则A * k = 2 ^ n ，则
  A / B = A * k >> n。
  所以对于 A / B, 只需找到一个k，使得 除数*k等于一个二的幂，并计算出n来移位即可
  ```

  原理十分易懂，但其有一些缺点：

  * 由于不能精确地使其变成二的幂，所以有一些上下取整的问题
  * 只能处理常数（K需要编译器来计算）

  由于与同学交流后发现其很容易产生bug，且时间不够，就没有来得及加上

* 所以最终只做了如下的优化：

  ```cpp
  x / 2^n = 
  		srl $a0, $s1, 31
  		addu $t0, $s1, $a0
  		sra $t3, $t0, 1
  x / -2^n = 
      	srl $a0, $s1, 31
  		addu $t0, $s1, $a0
  		sra $t3, $t0, 1
      	subi $t3, $zero, $t3
  0/x=0，x/1=x
  ```

##### 窥孔

（窥孔可以消除大量的冗余代码，作用极大）

   将中间代码和目标代码的分开窥孔了

* 目标代码

  * ```cpp
    //# PUSHADDR variable_4[0]
    //li $t1,0
    //li $t0,4
    //mult $t0,$t1
    //mflo $t0
    ```

    直接计算出值赋给$t0即可

  * ```cpp
    //li $t1,1
    //move $a3,$t1
    //
    //# $t6 = 0
    //li $t1,0
    //move $t0,$t1
    //move $t6,$t0
    ```

    直接li即可，循环了三次

  * ```cpp
    //运算多了个move
    //add $t0,$t4,$t7
    //move $t5,$t0
    ```

    将运算语句的目标寄存器直接改写

* 中间代码

  * ```cpp
    //ins_10 = ins_9 % 10
    //variable_3 = ins_10
    ```

    合并处理

##### 杂七杂八

* **while可以改写**（有坑）

  上面是原始while结构，下面是改进了的while结构

  ```cpp
  label1:
  if !<条件> goto label2
   <语句>
  goto label1
  label2:
  ```

  ```cpp
  goto label2
  label1:
   <语句>
  label2:
  if <条件> goto label1
  label3:
  ```

  显然，每次循环可以少一条goto语句。但是麻烦的点有不少：

  * 显然文法是：while\<cond>stmt，应该先分析条件，生成midcode，在处理stmt，所以需要在递归下降的时候手动调整代码顺序
  * continue是到label2，break是到label3，需要仔细
  * 全局寄存器的load和save需要进一步优化，否则会被这个优化给放大导致负优化

* **mul指令**比mult+mflo操作要少一个other
* subi $t0, $t1, 100用addi $t0,$t1, -100替换；



### 经历过的重构

出现过的设计未考虑到的事情：

* 首先是**词法分析后的数据存储**，一开始就想的是将token，string，line分别存储。但之后实现过程中发现可能存在匹配不上的风险，所以之后从新设计了新的数据结构对其进行了存储

  ```cpp
  struct completeSymbol{
      int symbol = 0;
      std::string stringContent;
      int line = 0;
  };
  ```

* **E类错误**的处理：

  之前想的就是分析是不是int类型即可，所以涉及到的函数返回值类型是bool。但之后发现需要对int进一步细分，维数的信息也要记录传递，所以return了int，对应如下-1：void 0：a 1：a[] 2：a\[][]。

* 递归下降的**判断细节**：

  由于之前递归下降的判断逻辑都为：如果出现A[B]c的情况，当需要判断B的存在时，可以用是不是c来判断。

  但是在错误处理中，尤其是IJK三类任务中，c有可能是缺失的，所以这种判断逻辑就行不通了。于是需要改变成判断First(B)的方式来进行判断。
  
* **代码生成阶段**

  ​	重构可太多了，挑几个毁灭级的

  * **mips地址空间**的分配使用，哪些部分可用，哪些部分大小合适等等。
  * **函数栈**的必要性：在被递归函数、间接递归函数hack爆的时候恍然大悟，之前一直是相当于都处理成了静态变量，与内存空间有一一对应。

  * 存$ra寄存器（这个是计组忘光了）

  * 函数栈的构造，数据的布局经过前思后想才确立了现在的结构。
  * 一开始以为**函数传参**也得用栈，并不能直接赋值，这是一个经典案例：min(r, scan(a,b))。后来发现在递归下降的处理过程中略微调整一下顺序即可解决。

* **代码优化阶段**

  此阶段的重构基本上是处于代码性能考虑

  * 函数传参：取消了参数栈，直接传到内存中，使用三个寄存器
  * while的控制流改写